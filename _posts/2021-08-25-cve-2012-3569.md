---
layout:     post
title:      漏洞分析（三）：CVE-2012-3569
subtitle:   VMware OVF Tool格式化字符串漏洞
date:       2021-08-25
author:     Hongtai S
header-img: img/10.jpg
catalog: true
tags:
    - 漏洞
    - 二进制
    - 格式化字符串漏洞
    - 跳板
    - shellcode
---
# CVE-2012-3569漏洞分析

## 一、漏洞信息

### 1. 漏洞简述

- 漏洞名称：VMware OVF Tool格式化字符串漏洞
- 漏洞编号：CVE-2012-3569
- 漏洞类型：格式化字符串漏洞
- 漏洞影响：信息泄露
- CVSS评分：9.3（High）
- 利用难度：Medium
- 基础权限：不需要

### 2. 组件概述

开放虚拟机格式（Open Virtual Machine Format，OVF）是一种虚拟机分配格式，能够支持不同产品与组织之间共享虚拟机。

VMware OVF Tool是由VMware免费提供的一款支持虚拟的导入导出工具，支持以命令提示符的方式运行。

### 4. 漏洞影响

VMware官网提供的影响版本。

![1.PNG](https://i.loli.net/2021/08/25/Ibu2LZU8nm5VMrq.png)

### 5. 解决方案

 - 更新软件

[官方文档链接](https://www.vmware.com/security/advisories/VMSA-2012-0015.html)  

## 二、漏洞分析

### 1. 基本信息

- 漏洞文件：poc.ovf、exp.ovf（《漏洞战争》配套资料）
- 漏洞函数：字符串打印函数std::basic_ostream
- 漏洞对象：ovf文档

### 2. 背景知识

#### 1. 格式化字符串漏洞

一段简单的代码：

```cpp,c
#include<stdio.h>
int main()
{
  char a[]="asdasd";
  printf(a);
  return 0;
}
```
其输出为：

```cpp,c
asdasd
```

上面的代码不会有什么问题，但是如果将字符串的输入权交给用户就会有问题了。看下面的代码：

```cpp,c
#include <stdio.h>
int main()
{
  char a[100];
  scanf("%s",str);
  printf(str);
  return 0;
}
```
如果用户输入的字符串是"%x%x%x"，则会输出以下结果：

```cpp,c
6efe4c6effcc753eca20
```

可以看到程序打印了一堆断码，这其中的原因是什么呢，先要从栈的布局说起：

函数调用栈的简化布局如图所示（其实栈中还有一些其他无关紧要的数据，笔者在图中没有画出）：

![2.PNG](https://i.loli.net/2021/08/25/hm2tzfyH9UeYGip.png)

正常情况下输出函数的语句应该是(前提是a、b、c已经赋值)：

```cpp,c
printf(str,a,b,c)
```
这时栈中结构如下，程序在处理字符串时发现了三个%x，就会在栈中检索三个变量的位置：

![3.PNG](https://i.loli.net/2021/08/25/AL8CtHsbkJj4uSG.png)

如果没有输入这三个变量，程序同样会向下检索三个“变量”，栈中布局如下：

![4.PNG](https://i.loli.net/2021/08/25/gQIHfa35ilkNsb1.png)

可以看到，我们竟然成功骗过程序，让其向下访问栈的地址空间，从而造成了内存泄漏。

理解基本原理后，我们看看其他格式化控制符：

%s ： 这个控制字符用于打印字符串，其原理是访问存放指向字符串的指针，进而从指针指向的位置打印“字符串”，直至打印到0x00这个截断符。
栈中的局部变量缓冲区存放字符串本身，而利用多个%s可以访问到局部变量缓冲区，如果输入的字符串是某个地址加上很多%s，当某一个%s访问到缓冲区字符串时，就会认为这个地址指向字符串，并打印这个地址空间的内容直至截断符，这样就做到了任意地址空间的访问。

%n 和 %hn ： %n是一个很特殊的格式化控制符，其功能不是打印，而是将目前已打印的字符个数写入对应的变量，如果触发格式化字符串漏洞，%n会将栈中某个位置的数据修改为目前打印出来的字符的个数，%n是以DWORD的形式写入，%hn以WORD形式写入。通过控制输出字符的数量和%n在字符串中的位置，可以达到修改栈中的任意数据的效果，甚至是EBP,返回地址等关键数据。

#### 2. 跳板技术

从汇编角度讲，在函数执行retn返回前，ESP刚好指向栈中存放返回地址的+0x4地址，若是发生栈溢出，将函数的返回地址覆盖为jmp/call esp的地址，剩下的部分覆盖为shellcode，程序就会在返回时自动跳转到shellcode地址，这种方法能够增加shellcode的写入空间，并且绕过ASLR。

### 3. 详细分析

#### 1. 基础分析

参考《漏洞战争》及其配套资料，安装VMware OVF Tool 2.1.0，将poc.vof和exp.vof放到安装路径中，命令行进入安装路径

输入命令voftool poc.ovf：

![5.PNG](https://i.loli.net/2021/08/25/5lrtI3muFfAbeZi.png)

![6.PNG](https://i.loli.net/2021/08/25/79GQqvnaHwycZoI.png)

可以看到终端先打印了一堆字符串后，系统报出内存访问错误，查看详细报告：

![7.PNG](https://i.loli.net/2021/08/25/kNhSYVJltB5D3HC.png)

报告中显示程序访问了错误的地址0x00000000

在010 Editor中查看poc.ovf文件：

![8.PNG](https://i.loli.net/2021/08/25/j62CAy8w5Ne7YQS.png)

能够看到文件中存在一大段字符串，并且存在大量的格式控制符%08x，用于打印8位十六进制数（高位填充0）。

#### 2. 静态分析

##### Ida分析

使用Ida打开ovftool,查看std::basic_ostream函数所在的源码：

```cpp,c
v36 = v30[5];
v20 = (int (__thiscall **)(_DWORD, _DWORD, _DWORD))(*(_DWORD *)v30[5] + 16);
v21 = (*(int (__thiscall **)(int, int))(*(_DWORD *)v4 + 44))(v4, v19);
v22 = (*v20)(v36, &v28, v21);
v31 = 1;
v23 = v22;
v24 = sub_401A90(&dword_160C7D8, " - ");
v25 = std::operator<<<char,std::char_traits<char>,std::allocator<char>>(v24, v23);
std::basic_ostream<char,std::char_traits<char>>::operator<<(v25, std::endl);   //此处没有对参数进行过滤，导致格式化字符串漏洞
v31 = -1;
std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(&v28); 
++v19;
result = (*(int (__thiscall **)(_DWORD))(*(_DWORD *)v4 + 36))(v4)
```
可以看到std::basic_ostream函数没有对参数进行过滤，导致格式化字符串漏洞。

#### 3. 动态分析

##### 1. 分析poc.ovf

启动OD，设置调试-参数，输入poc.ovf，打开ovftool运行至结束，由于刚才的输入信息中包含Invalid value字符串，在反汇编窗口中右键-查找-所有参考文本字串：

![9.PNG](https://i.loli.net/2021/08/25/JKQ5dxqmsYSyODH.png)

找到“Invalid value”，双击转到引用字符串的命令，并在其附近设下断点：

![10.PNG](https://i.loli.net/2021/08/25/wV39vjlLqU2IGtJ.png)

可以看到附近的函数都是C++的std，继续F8运行数次后能够找到std::basic_ostream这个C++打印函数

![11.PNG](https://i.loli.net/2021/08/25/18XJ3zvEorndqib.png)

查看当前函数的EBP链：

![12.PNG](https://i.loli.net/2021/08/25/Gj1LXkzBlvp2u4W.png) ![13.PNG](https://i.loli.net/2021/08/25/eDWtc5NPxKY9mr6.png)

可以看到整个函数调用栈的EBP链分别为：

0012FC1C - 0012FC74 - 0012FF50 - 0012FF7C - 0012FFC0 - 0012FFF0

单步步过这个函数后在查看EBP链：

![14.PNG](https://i.loli.net/2021/08/25/PRDXmZb6JBykinL.png) ![15.PNG](https://i.loli.net/2021/08/25/eu4YDyScN8lfioZ.png)

0012FC1C - 0012FC74 - 0012FF50 - **00120345**

可以明显看到0012FF50这个EBP指向的上一个栈的栈帧被修改为00120345，初步判断是由于格式化字符串造成的，打开101 Editor统计字符串。

```cpp,c
"AAAAAAAAAAAAAAAAAAAAAAAAAA%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%hn"
```

通过统计得出字符串中共有26个'A',98个%08x和1个%hn，在%hn之前打印出的字符数量应为26 + 98*8 = 810,810的十六进制数刚好是0x345。通过%hn将EBP的第四位赋值为0345，使得EBP由0012FF7C被覆盖为00120345。

继续跟进知道EBP被赋值为00120345：

![16.PNG](https://i.loli.net/2021/08/25/CErxMKZLuyVR6jN.png)

可以看到程序执行完00417AEF处的指令pop ebp后，EBP的值被覆盖为00120345，继续运行：

![17.PNG](https://i.loli.net/2021/08/25/zFSKMClw8bsftBG.png)

运行后ESP也被赋值为00120345，而此时00120345处的地址内容为00000000，在接下来的retn指令执行后，eip被修改为00000000，从而导致系统访问00000000这个无效地址，造成报错。

##### 1. 分析exp.ovf

与分析poc.ovf分析方式类似，将程序执行至std::basic_ostream这个函数，查看EBP链：

![18.PNG](https://i.loli.net/2021/08/25/pJ6Yfsa3LRb7ydi.png) ![19.PNG](https://i.loli.net/2021/08/25/uOQfzeo8RLD6Fqi.png)

EBP链为：

0012FC1C - 0012FC74 - 0012FF50 - 0012FF7C - 0012FFC0 - 0012FFF0

步过函数后：

![20.PNG](https://i.loli.net/2021/08/25/nmWZVJ6Xa5PTuF7.png) ![21.PNG](https://i.loli.net/2021/08/25/RzMaxw6T1sip8cy.png)

可以看到EBP链被修改为：

0012FC1C - 0012FC74 - 0012FF50 - **00121000**

EBP已经被修改为00121000，继续运行至ESP被修改为00121000：

![22.PNG](https://i.loli.net/2021/08/25/sRLNn4OtgvVkwmj.png)

继续运行pop ebp后，ESP值变为00121004，retn后eip被修改为00121004处的内容，查看00121004存放的地址7852753D对应的对应的反汇编：

![23.PNG](https://i.loli.net/2021/08/25/RL86dwtluTcyg7f.png)

反汇编为call esp，是一个跳板指令，能够将程序执行流劫持到00121008，在数据窗口中定位121008：

![24.PNG](https://i.loli.net/2021/08/25/2Bbs3kJryv7zHhT.png)

能够看到大量的字符串，将向上查找能够找到字符串的开始“znHt...”

![25.PNG](https://i.loli.net/2021/08/25/GC4lejgMrEd92Xh.png)

![26.PNG](https://i.loli.net/2021/08/25/6iYd2Ib1tRF5WSn.png)

继续运行此处发现出现循环，并且内存中的字符串逐渐变为不可打印的字符：

![27.PNG](https://i.loli.net/2021/08/25/CZLFmrqHIzk4fVD.png)

说明shellcode正在进行解码操作，继续跟进后寄存器窗口中出现相关函数及其参数，并跳出对话框

![28.PNG](https://i.loli.net/2021/08/25/mn5XypAg9Ta3rJE.png)

## 三、缓解措施

更新软件

## 四、参考文献

《0day安全：软件漏洞分析技术》

《漏洞战争》

[博客园：CVE-2012-3569：VMware OVF Tool 格式化字符串漏洞调试分析](https://www.cnblogs.com/csnd/p/11800522.html)

[看雪：CVE-2012-3569 VMWare OVF Tools 格式化字符串漏洞分析](https://bbs.pediy.com/thread-219224.htm)

[CSDN：格式化字符串漏洞原理详解](https://blog.csdn.net/qq_43394612/article/details/84900668)

[bilibili：XMCVE 2020 CTF Pwn入门课程](https://www.bilibili.com/video/BV1854y1y7Ro?p=9)
